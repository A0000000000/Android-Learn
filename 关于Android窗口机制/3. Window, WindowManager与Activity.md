# Window, WindowManager与Activity

* Window, WindowManager的结构图
![结构图](3.1.窗口结构.png)

## 关于图中的各个类

### 1. ViewManager
* 源代码
    ```java
    public interface ViewManager
    {
        public void addView(View view, ViewGroup.LayoutParams params);
        public void updateViewLayout(View view, ViewGroup.LayoutParams params);
        public void removeView(View view);
    }
    ```
* 可以看到ViewManager是一个接口, 它里面定义了一组规则, 也就是添加, 更新, 删除View的接口, 即ViewManager是用来添加, 更新和删除Activity中View的接口, 可以通过Context.getSystemService()获取实例

### 2. ViewGroup
* 源代码
    ```java
    public abstract class ViewGroup extends View implements ViewParent, ViewManager {
        ...
        public void addView(View child) {
            addView(child, -1);
        }
        ...
        public void addView(View child, int index) {
            if (child == null) {
                throw new IllegalArgumentException("Cannot add a null child view to a ViewGroup");
            }
            LayoutParams params = child.getLayoutParams();
            if (params == null) {
                params = generateDefaultLayoutParams();
                if (params == null) {
                    throw new IllegalArgumentException(
                            "generateDefaultLayoutParams() cannot return null");
                }
            }
            addView(child, index, params);
        }
        ...
        public void addView(View child, int index, LayoutParams params) {
            if (DBG) {
                System.out.println(this + " addView");
            }

            if (child == null) {
                throw new IllegalArgumentException("Cannot add a null child view to a ViewGroup");
            }
            requestLayout();
            invalidate(true);
            addViewInner(child, index, params, false);
        }
        ...
    }
    ```
    * ViewGroup实现了ViewManager接口, View通过ViewGroup的addView方法添加到ViewGroup中, 而ViewGroup层层嵌套到最顶级都会显示在一个窗口的Window中

### 3. WindowManager
* 源代码(代码太多, 这里只拷贝关键代码)
    ```java
    public interface WindowManager extends ViewManager {
        public static class BadTokenException extends RuntimeException {
            ...
        }
        public static class InvalidDisplayException extends RuntimeException {
            ...
        }
        public Display getDefaultDisplay()；
        public void removeViewImmediate(View view);
        public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable {
            ...
        }
        ...
    }
    ```
    * WindowManager是一个接口, 继承自ViewManager, WindowManager意思是窗口管理器, 每一个窗口管理器都与一个窗口的显示绑定. 通过Context.getSystemService(Context.WINDOW_SERVICE)获取实例, 因为其继承了ViewManager, 所以它可以进行添加删除View, 不过具体实现在其实现类WindowManagerImpl中.
    * 关于BadTokenException
        1. 当addView时, 它的LayoutParams无效则会抛出
        2. 添加第二个View的时候没有移除第一个View会抛出
    * 关于InvalidDisplayException
        * 如果一INDOW_SERVICE)获取实例, 因为其继承了ViewManager, 所以它可以进行添加删除View, 不过具体实现在其实现类WindowManagerImpl中.
    * 关于BadTokenException
        1. 当addView时, 它的LayoutParams无效则会抛出
        2. 添加第二个View的时候没有移除第一个View会抛出
    * 关于InvalidDisplayException
        * 如果一个窗口是在一个二级的显示上, 而指定的显示找不到则会被抛出
    * 关于getDefaultDisplay
        * 返回当前WindowManager管理的显示Display
    * 关于removeViewImmediate
        * 表示从窗口上移除View, 一般是当View调用了onDetachedFromWindow也就是从Window上分开后, 把它移除
    * 关于LayoutParams
        * Window的布局参数, 里面定义了一系列的窗口属性
    

### 4. WindowManagerImpl
* 源代码(部分)
    ```java
    public final class WindowManagerImpl implements WindowManager {
        private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();
        private final Display mDisplay;
        private final Window mParentWindow;
        @Override
        public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
            applyDefaultToken(params);
            mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow, mContext.getUserId());
        }
        ...
        @Override
        public void removeView(View view) {
            mGlobal.removeView(view, false);
        }
    }
    ```
    * 关于增加删除的代码, 可以看到实际上是调用了WindowManagerGlobal里面的方法, WindowManagerImpl只是做了一层嵌套

## 关于这些类之间的联系

* 每一个Activity都会与一个Window绑定在一起, 所以Window的创建和WindowManager的绑定是在创建启动Activity过程中绑定的
* 关于Activity的启动, 有两种方式
    1. 点击程序进入Activity
    2. 通过在已启动的Activity中调用startActivity
* Activity启动期间通过Binder驱动ActivityWindowService, ActivityThread, ApplicationThread, ActivityStack, Activity之间进行通讯, 为当前Activity创建进程, 分配任务栈后启动Activity
* Activity的创建过程 --ActivityThread.handleLaunchActivity
    ```java
        @Override
        public Activity handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent) {
            unscheduleGcIdler();
            ...
            WindowManagerGlobal.initialize();
            GraphicsEnvironment.hintActivityLaunch();
            final Activity a = performLaunchActivity(r, customIntent);
            if (a != null) {
                r.createdConfig = new Configuration(mConfiguration);
                reportSizeConfigurations(r);
                if (!r.activity.mFinished && pendingActions != null) {
                    pendingActions.setOldState(r.state);
                    pendingActions.setRestoreInstanceState(true);
                    pendingActions.setCallOnPostCreate(true);
                }
            } else {
                ...
            }
            return a;
        }
    ```
    1. WindowManagerGlobal.initialize() 是在创建WindowManagerSerivice(如过没创建的话), 代码如下.
    ![initialize方法](3.2.WindowManagerGlobal.initialize.png)
    2. 初始化完WindowManagerSerivice后, 调用performLaunchActivity来创建Activity
        ```java
        private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
            ...
            Activity activity = null;
            try { 
                //Activity通过ClassLoader创建出来
                java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
                activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);  
            } 
            ...
            //创建Application
            try {
                Application app = r.packageInfo.makeApplication(false, mInstrumentation);
                ...
                if (activity != null) {
                    //创建Activity所需的Context
                    Context appContext = createBaseContextForActivity(r, activity);
                    ...
                    //将Context与Activity进行绑定
                    activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo,  title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor);
                    ...
                    //调用activity.onCreate
                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
                    ...
                }
            }
            ...
            return activity;
        }
        ```
        1. Activity是通过mInstrumentation的newActivity来创建的, 可以发现, 最后是通过ClassLoader反射创建而来的
        ![newActivity](3.3.newActivity.png)
        ![instantiateActivity](3.4.instantiateActivity.png)
        2. 创建完成Activity后, 接着创建所需要的Application和Context
        3. 然后调用Activity的attach方法来将Application和Context建立关联
            ```java
                final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor) {
                //ContextImpl的绑定
                attachBaseContext(context);
                //在当前Activity创建Window
                mWindow = new PhoneWindow(this);
                mWindow.setCallback(this);
                mWindow.setOnWindowDismissedCallback(this);
                mWindow.getLayoutInflater().setPrivateFactory(this);
                ...
                //为Window设置WindowManager
                mWindow.setWindowManager(
                        (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),
                        mToken, mComponent.flattenToString(),
                        (info.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);
                if (mParent != null) {
                    mWindow.setContainer(mParent.getWindow());
                }
                //创建完后通过getWindowManager就可以得到WindowManager实例
                mWindowManager = mWindow.getWindowManager();
                mCurrentConfig = config;
            }
            ```
            * 在Activity调用attach的时候, 对应的Window对象也被创建(第2篇文章有提到), 同时也将Window和WindowManager进行绑定. mWindow和mWindowManager是Activity的成员变量, mWindowManager是在setWindowManager时创建的
            ![setWinowManager](3.5.setWindowManager.png)
        4. attach方法结束后, 执行mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState), 即在调用Activity的onCreate方法
        ![callActivityOnCreate](3.6.callActivityOnCreate.png)
        ![performCreate](3.7.performCreate.png)
        
* Activity的创建过程 --ActivityThread.handleStartActivity
    ```java
        @Override
        public void handleStartActivity(IBinder token, PendingTransactionActions pendingActions) {
            final ActivityClientRecord r = mActivities.get(token);
            final Activity activity = r.activity;
            ...
            activity.performStart("handleStartActivity");
            r.setState(ON_START);
            ...
            if (pendingActions.shouldRestoreInstanceState()) {
                if (r.isPersistable()) {
                    if (r.state != null || r.persistentState != null) {
                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,
                                r.persistentState);
                    }
                } else if (r.state != null) {
                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);
                }
            }
            if (pendingActions.shouldCallOnPostCreate()) {
                activity.mCalled = false;
                if (r.isPersistable()) {
                    mInstrumentation.callActivityOnPostCreate(activity, r.state,
                            r.persistentState);
                } else {
                    mInstrumentation.callActivityOnPostCreate(activity, r.state);
                }
                ...
            }
            updateVisibility(r, true);
            mSomeActivitiesChanged = true;
        }
    ```
## 参考
* [简书](https://www.jianshu.com/p/6afb0c17df43)